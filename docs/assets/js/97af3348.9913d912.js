"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[68],{7345:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"caches","title":"Caches","description":"In addition to the standard step-level caching that buildkit provides, you can","source":"@site/docs/caches.md","sourceDirName":".","slug":"/caches","permalink":"/dalec/caches","draft":false,"unlisted":false,"editUrl":"https://github.com/Azure/dalec/blob/main/website/docs/caches.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Extra Repository Configs","permalink":"/dalec/repositories"},"next":{"title":"Signing Packages","permalink":"/dalec/signing"}}');var c=i(4848),t=i(8453);const a={},o="Caches",r={},d=[{value:"Dir Cache",id:"dir-cache",level:2},{value:"Gobuild Cache",id:"gobuild-cache",level:2},{value:"Bazel Cache",id:"bazel-cache",level:2},{value:"Remote Cache",id:"remote-cache",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"caches",children:"Caches"})}),"\n",(0,c.jsxs)(n.p,{children:["In addition to the standard step-level caching that buildkit provides, you can\nalso configure incremental caching that persists across builds.\nThis is similar to Dockerfiles ",(0,c.jsx)(n.code,{children:"--mount=type=cache"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"You can provide multiple cache configurations:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - dir:\n      key: my_key\n      dest: /my/cache/dir\n      sharing: shared\n  - dir:\n      key: my_other_key\n      dest: /my/other/cache/dir\n      sharing: private\n  - gobuild:\n  - bazel:\n"})}),"\n",(0,c.jsx)(n.h2,{id:"dir-cache",children:"Dir Cache"}),"\n",(0,c.jsx)(n.p,{children:"Dir caches are just generic directories where you choose the cache key and sharing mode."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - dir:\n      key: my_key\n      dest: /my/cache/dir\n      sharing: shared\n"})}),"\n",(0,c.jsx)(n.p,{children:"Supported sharing modes are:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"shared"}),": The cache is shared between all builds."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"private"}),": The cache is private to the build."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"locked"}),": The cache is locked to the build. This is useful for caching directories that are not thread-safe."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["By default, dalec will namespace these directories with a key tied to the OS and\nCPU architecture which is prepended to the key you provide. This is to help\nprevent common issues one would see for specific use-cases such as storing\nincremental compiler caches.\nYou can disable this behavior by setting the ",(0,c.jsx)(n.code,{children:"no_auto_namespace"})," option to ",(0,c.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - dir:\n      key: my_key\n      dest: /my/cache/dir\n      sharing: shared\n      no_auto_namespace: true\n"})}),"\n",(0,c.jsx)(n.p,{children:"This will disable the automatic namespacing and use the key you provide as-is."}),"\n",(0,c.jsx)(n.h2,{id:"gobuild-cache",children:"Gobuild Cache"}),"\n",(0,c.jsxs)(n.p,{children:["The gobuild cache is a special type of cache that is used to cache the results of\nthe ",(0,c.jsx)(n.code,{children:"go build"})," command.\nThis is useful for caching the results of the build, such as the binary or\nlibraries."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - gobuild:\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Go build caches are always in ",(0,c.jsx)(n.code,{children:"shared"})," mode and are always namespaced with the OS and CPU architecture."]}),"\n",(0,c.jsxs)(n.p,{children:["An optional ",(0,c.jsx)(n.code,{children:"scope"})," can be provided which is added to the generated cache key.\nThis is intended for internal testing purposes, however may be useful for other\nuse-cases as well."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - gobuild:\n      scope: my_scope\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Finally, when go is detected in the build environment dalec will automatically\ncreate a gobuild cache for you. This can be disabled by setting the ",(0,c.jsx)(n.code,{children:"disabled"}),"\noption to ",(0,c.jsx)(n.code,{children:"true"})," in the cache definition."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - gobuild:\n      disabled: true\n"})}),"\n",(0,c.jsx)(n.h2,{id:"bazel-cache",children:"Bazel Cache"}),"\n",(0,c.jsxs)(n.p,{children:["The bazel cache is a special type of cache that is used to cache the results of\nthe ",(0,c.jsx)(n.code,{children:"bazel build"})," command."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - bazel:\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Bazel caches are always in ",(0,c.jsx)(n.code,{children:"shared"})," mode and are always namespaced with the OS and CPU architecture.\nThis relies on setting the ",(0,c.jsx)(n.code,{children:"--disk_cache"})," flag on ",(0,c.jsx)(n.code,{children:"bazel build"})," by adding it to the ",(0,c.jsx)(n.em,{children:"system"})," bazelrc file\nwhen dalec sets up the build environment.\nDalec does not check if this is overwritten in the user or project bazelrc files.\nIf this conflicts with your project, you may need to manually manage the bazel cache with a ",(0,c.jsx)(n.a,{href:"#dir-cache",children:"cache dir"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["An optional ",(0,c.jsx)(n.code,{children:"scope"})," can be provided which is added to the generated cache key.\nThis is intended for internal testing purposes, however may be useful for other\nuse-cases as well."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"caches:\n  - bazel:\n      scope: my_scope\n"})}),"\n",(0,c.jsx)(n.h3,{id:"remote-cache",children:"Remote Cache"}),"\n",(0,c.jsxs)(n.p,{children:["Bazel supports remote caching. When bazel caching is enabled in the spec dalec will look for a socket ID, ",(0,c.jsx)(n.code,{children:"bazel-default"}),",\nwhich is provided by a buildkit client and forward it into the build environment adding the appropriate configuration to\nbazelrc."]}),"\n",(0,c.jsxs)(n.admonition,{type:"note",children:[(0,c.jsxs)(n.p,{children:["If using docker buildx, you will need to set ",(0,c.jsx)(n.code,{children:"--ssh socket=<path>,raw=true"}),", which requires buildx version 0.25.0 or later."]}),(0,c.jsxs)(n.p,{children:["DALEC provides a (go) library to help with this in the ",(0,c.jsx)(n.code,{children:"sessionutil/socketprovider"})," package that you can use with a custom buildkit client integration.\nThese are generic and not specific to dalec or bazel caching, so they must be configured based on your needs."]})]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"socketprovider.SocketProxy"})," - This implements the required interface to pass sockets to buildkit."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"socketprovider.Mux"})," - Routes requests for sockets to different backends,\nthis is needed if you'll want to also expose multiple socket forwarding agents to the build -- for example, a standard SSH agent and a bazel remote cache connection. This acts sort of like an http.ServeMux but for buildkit's\nsocket forwarding implementation, where a request comes in with a socket ID and\nthe mux routes it to the appropriate backend based on the ID, which is up to you\nto configure how you want those routes to be handled."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["These implement the\n",(0,c.jsx)(n.a,{href:"https://pkg.go.dev/github.com/moby/buildkit/session#Attachable",children:"session.Attachable"})," interface and need to be provided to the\n",(0,c.jsx)(n.a,{href:"https://pkg.go.dev/github.com/moby/buildkit/client#SolveOpt",children:"SolveOpt"})," in the ",(0,c.jsx)(n.code,{children:"Session"})," field when starting a build."]}),"\n",(0,c.jsx)(n.p,{children:"The way this works is the buildkit client is expected to provide a set of GRPC API's tunnelled through a \"session\".\nThe buildkit solver will call those API's for a nunmber of things, including fetching files, authentication, and in this case\nforwarding sockets.\nThe API's for forwarding sockets are designed around forwarding SSH agents, but the buildkit solver doesn't care about SSH\nor the agent protocol at all.\nThe docker CLI, however, is expecting to only provide SSH agent forwarding and is not able to be used with generic proxies like\nis provided in these libraries.\nAny buildkit server should work with this, it is just that the buildkit client requires special configuration to do this."}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://github.com/buchgr/bazel-remote",children:"bazel-remote"})," is an example of a remote bazel caching server, but technically any\nimplementation of the ",(0,c.jsx)(n.a,{href:"https://bazel.build/remote/caching",children:"bazel remote caching protocol"})," can be used."]})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const c={},t=s.createContext(c);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);