"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[359],{3719:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"system-extensions","title":"System Extensions (EXPERIMENTAL)","description":"Dalec can create system extensions, known as sysexts, for use with systemd. Such extensions are filesystem images that get overlaid onto an existing running system. These are often designed to be standalone, making them very portable, but they don\'t necessarily have to be.","source":"@site/docs/system-extensions.md","sourceDirName":".","slug":"/system-extensions","permalink":"/dalec/system-extensions","draft":false,"unlisted":false,"editUrl":"https://github.com/Azure/dalec/blob/main/website/docs/system-extensions.md","tags":[],"version":"current","frontMatter":{"title":"System Extensions (EXPERIMENTAL)"},"sidebar":"sidebar","previous":{"title":"Virtual Packages","permalink":"/dalec/virtual-packages"},"next":{"title":"Dalec Specification","permalink":"/dalec/spec"}}');var i=n(4848),r=n(8453);const l={title:"System Extensions (EXPERIMENTAL)"},o=void 0,a={},c=[{value:"How it Works",id:"how-it-works",level:2},{value:"Example: System extension with jq and zsh",id:"example-system-extension-with-jq-and-zsh",level:2},{value:"Tips",id:"tips",level:2},{value:"glibc compatibility",id:"glibc-compatibility",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Conflicts",id:"conflicts",level:3},{value:"Static linking",id:"static-linking",level:3},{value:"Prefixing",id:"prefixing",level:3},{value:"Permitted paths",id:"permitted-paths",level:3},{value:"Ownership",id:"ownership",level:3}];function d(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"Dalec can create system extensions, known as sysexts, for use with systemd. Such extensions are filesystem images that get overlaid onto an existing running system. These are often designed to be standalone, making them very portable, but they don't necessarily have to be."}),"\n",(0,i.jsx)(s.h2,{id:"how-it-works",children:"How it Works"}),"\n",(0,i.jsx)(s.p,{children:"System extensions satisfy a different use case to containers. Whether a extension should be standalone and exactly which dependencies it should include ultimately depends on where it will be merged in practise. As such, a sysext-specific dependency type is used by Dalec to give you full control over what is included."}),"\n",(0,i.jsx)(s.p,{children:"The system extension is created from packages, either built from the same spec or elsewhere, but unlike with containers, the packages are extracted directly rather than installed by a package manager. Consequently, no dependency resolution is performed, and no package metadata is written."}),"\n",(0,i.jsxs)(s.p,{children:["The result is a single ",(0,i.jsx)(s.a,{href:"https://erofs.docs.kernel.org",children:"EROFS"})," image file. This can be merged against just about any system running systemd 248 or later."]}),"\n",(0,i.jsx)(s.h2,{id:"example-system-extension-with-jq-and-zsh",children:"Example: System extension with jq and zsh"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:"# syntax=ghcr.io/azure/dalec/frontend:latest\nname: my-sysext\nversion: 0.1.0\nrevision: 1\nlicense: MIT\ndescription: A system extension with some useful tools\n\ndependencies:\n  sysext:\n    jq:\n    zsh:\n"})}),"\n",(0,i.jsx)(s.p,{children:"Build the container:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-shell",children:"docker build -f my-sysext.yml --target=azlinux3/testing/sysext --output=. .\n"})}),"\n",(0,i.jsxs)(s.p,{children:["This creates ",(0,i.jsx)(s.code,{children:"my-sysext-v0.1.0-1-azlinux3-x86-64.raw"})," in the current directory. You can merge this with ",(0,i.jsx)(s.code,{children:"systemd-sysext"})," or just mount it to some directory with ",(0,i.jsx)(s.code,{children:"mount -o loop"}),". It contains:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"jq"}),", ",(0,i.jsx)(s.code,{children:"zsh"})," and their associated files"]}),"\n",(0,i.jsx)(s.li,{children:"Some system extension metadata"}),"\n",(0,i.jsx)(s.li,{children:"That's it!"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"--target=azlinux3"})," flag tells Dalec to source the packages from Azure Linux 3 repositories, but you can merge the extension against other distributions."]}),"\n",(0,i.jsx)(s.h2,{id:"tips",children:"Tips"}),"\n",(0,i.jsx)(s.h3,{id:"glibc-compatibility",children:"glibc compatibility"}),"\n",(0,i.jsx)(s.p,{children:"In the above example, the binaries are dynamically linked against glibc from Azure Linux 3. Bear in mind that glibc is not forwards-compatible, so while you can merge the extension against other distributions, these binaries will not work against older releases such as Ubuntu 22.04."}),"\n",(0,i.jsx)(s.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,i.jsxs)(s.p,{children:["In the above example, jq also requires ",(0,i.jsx)(s.code,{children:"libonig.so.5"})," at the time of writing. This library is unlikely to be present on most systems, so it should either be installed before merging or included with the extension by adding ",(0,i.jsx)(s.code,{children:"oniguruma"})," under ",(0,i.jsx)(s.code,{children:"sysext"}),". Do whatever is most appropriate for your use case."]}),"\n",(0,i.jsx)(s.h3,{id:"conflicts",children:"Conflicts"}),"\n",(0,i.jsx)(s.p,{children:"Files on the running system will be overshadowed by those in the system extension if they have the same path. Care must therefore be taken to ensure you don't break the running system by including incompatible files. For example, it is vitally important that you don't include glibc unless it has been installed to an alternative path. Note that the running system is not modified by the merge, and the original files become visible again when unmerging."}),"\n",(0,i.jsx)(s.h3,{id:"static-linking",children:"Static linking"}),"\n",(0,i.jsx)(s.p,{children:"The above issues can be largely avoided by including statically-linked rather than dynamically-linked binaries. This will make your system extension much more portable. However, binaries shipped by distributions are practically always dynamic, so this will require you to build the binaries and their dependencies yourself as part of the spec."}),"\n",(0,i.jsx)(s.h3,{id:"prefixing",children:"Prefixing"}),"\n",(0,i.jsxs)(s.p,{children:["If conflicts are likely to occur, even when static linking, the extension can place its files under a unique prefix, e.g. ",(0,i.jsx)(s.code,{children:"/usr/local/my-sysext"}),". For this to work, the binaries should be built specifically for this prefix, e.g. ",(0,i.jsx)(s.code,{children:"./configure --prefix=/usr/local/my-sysext"}),". Dynamically-linked binaries should explicitly include somewhere like ",(0,i.jsx)(s.code,{children:"/usr/local/my-sysext/lib"})," in the ",(0,i.jsx)(s.code,{children:"RUNPATH"})," to avoid the need for wrappers that set ",(0,i.jsx)(s.code,{children:"LD_LIBRARY_PATH"}),". If executables rely on other executables, then wrappers are still needed to add ",(0,i.jsx)(s.code,{children:"/usr/local/my-sysext/bin"})," to the ",(0,i.jsx)(s.code,{children:"PATH"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"permitted-paths",children:"Permitted paths"}),"\n",(0,i.jsxs)(s.p,{children:["System extensions will only merge files under ",(0,i.jsx)(s.code,{children:"/usr"})," and ",(0,i.jsx)(s.code,{children:"/opt"}),". Files located elsewhere will not appear once merged. For this reason, ",(0,i.jsx)(s.code,{children:"/bin"}),", ",(0,i.jsx)(s.code,{children:"/sbin"}),", ",(0,i.jsx)(s.code,{children:"/lib"})," and ",(0,i.jsx)(s.code,{children:"/lib64"})," are automatically relocated under ",(0,i.jsx)(s.code,{children:"/usr"})," by Dalec."]}),"\n",(0,i.jsxs)(s.p,{children:["systemd supports configuration extensions, known as confexts, for handling ",(0,i.jsx)(s.code,{children:"/etc"}),", but these are not yet supported by Dalec. In the meantime, anything installed under ",(0,i.jsx)(s.code,{children:"/etc"})," by the spec is relocated under ",(0,i.jsx)(s.code,{children:"/usr/share/<NAME>/etc"}),", and a tmpfiles.d entry is created to copy these files to ",(0,i.jsx)(s.code,{children:"/etc"})," when the extension is merged. They are not removed when the extension is unmerged."]}),"\n",(0,i.jsx)(s.h3,{id:"ownership",children:"Ownership"}),"\n",(0,i.jsxs)(s.p,{children:["The UIDs and GIDs of the running system may not match those used to build the extension, so Dalec automatically changes all user and group ownership to ",(0,i.jsx)(s.code,{children:"root:root"})," when creating the extension."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>o});var t=n(6540);const i={},r=t.createContext(i);function l(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);