"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[822],{1685:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var t=i(4848),a=i(8453);const s={title:"Quickstart"},c=void 0,r={id:"quickstart",title:"Quickstart",description:'In this section, we\'ll go over how to build packages and containers from source with Dalec. Note that, in this context, "source" refers to the source code of the package being built. Before continuing, it is first useful to go over some preliminary background.',source:"@site/docs/quickstart.md",sourceDirName:".",slug:"/quickstart",permalink:"/dalec/quickstart",draft:!1,unlisted:!1,editUrl:"https://github.com/Azure/dalec/blob/main/website/docs/quickstart.md",tags:[],version:"current",frontMatter:{title:"Quickstart"},sidebar:"sidebar",previous:{title:"Overview",permalink:"/dalec/build"},next:{title:"Container-only builds",permalink:"/dalec/container-only-builds"}},o={},l=[{value:"Some Preliminaries",id:"some-preliminaries",level:2},{value:"But what actually <em>is</em> Dalec?",id:"but-what-actually-is-dalec",level:3},{value:"Targets",id:"targets",level:3},{value:"Stages of a Dalec Build",id:"stages-of-a-dalec-build",level:3},{value:"Creating a Package and Container from Source",id:"creating-a-package-and-container-from-source",level:2},{value:"Building using Docker",id:"building-using-docker",level:2},{value:"Building just an RPM package",id:"building-just-an-rpm-package",level:3},{value:"Building a Container with the Package Installed",id:"building-a-container-with-the-package-installed",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'In this section, we\'ll go over how to build packages and containers from source with Dalec. Note that, in this context, "source" refers to the source code of the package being built. Before continuing, it is first useful to go over some preliminary background.'}),"\n",(0,t.jsx)(n.h2,{id:"some-preliminaries",children:"Some Preliminaries"}),"\n",(0,t.jsxs)(n.h3,{id:"but-what-actually-is-dalec",children:["But what actually ",(0,t.jsx)(n.em,{children:"is"})," Dalec?"]}),"\n",(0,t.jsxs)(n.p,{children:["Dalec is what is known as a ",(0,t.jsx)(n.em,{children:"frontend"})," for ",(0,t.jsx)(n.a,{href:"https://docs.docker.com/build/buildkit/frontend/",children:"Docker Buildkit"}),". If you've ever used a ",(0,t.jsx)(n.code,{children:"Dockerfile"})," before (under newer versions of docker) you have interacted with a buildkit frontend. A frontend is a little like a compiler in that it translates higher level syntax into specific build instructions which the buildkit engine knows how to execute. Dalec, then, provides a specialized spec format for specifying particular artifacts -- in this case packages and containers -- and then translates that spec into build instructions to be run in buildkit. This is why Dalec has no dependencies other than Docker -- it actually becomes a component loaded during the docker build."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"syntax"})," line tells buildkit the parser to use so it can understand the dalec spec format. Essentially, it specifies which ",(0,t.jsx)(n.em,{children:"frontend"})," to use. Having ",(0,t.jsx)(n.code,{children:"# syntax=ghcr.io/azure/dalec/frontend:latest"})," is required at the top of the Dalec spec file. It is possible to pin the frontend to a specific version tag, as in ",(0,t.jsx)(n.code,{children:"# syntax=ghcr.io/azure/dalec/frontend:0.10"}),"\nFor information about changes in specific releases of Dalec, see the ",(0,t.jsx)(n.a,{href:"https://github.com/Azure/dalec/releases",children:"release notes"})," page."]})}),"\n",(0,t.jsx)(n.h3,{id:"targets",children:"Targets"}),"\n",(0,t.jsxs)(n.p,{children:["First, a word on ",(0,t.jsx)(n.strong,{children:"targets"}),": A target refers to a specific output of a dalec build. Dalec can produce different types of outputs, such as RPMs, DEBs, and container images. For a full list of available targets, see the ",(0,t.jsx)(n.a,{href:"/dalec/targets",children:"targets"})," section."]}),"\n",(0,t.jsx)(n.h3,{id:"stages-of-a-dalec-build",children:"Stages of a Dalec Build"}),"\n",(0,t.jsx)(n.p,{children:"A Dalec build generally happens in up to three main stages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Package Build"})," - This is where the sources are checked out and built using the build steps defined in the spec file. The output of this phase is an actual package, such as an RPM or DEB. These steps execute in the build environment, which is a worker container image with the necessary build dependencies installed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Package Test"}),": Depends on ",(0,t.jsx)(n.strong,{children:"Package Build"})," - This is where the package is installed in a clean environment and tested to ensure it was built correctly -- for example, to ensure that package artifacts are installed in the proper locations and have the correct permissions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Create Output Image"})," (optional) - Depends on ",(0,t.jsx)(n.strong,{children:"Package Test"}),", ",(0,t.jsx)(n.strong,{children:"Package Build"}),". At this stage, Dalec will install a package built in stage (1) into a base image for the resulting ",(0,t.jsx)(n.strong,{children:"output container image"})," to be created. There may be additional runtime dependencies specified in the spec file that are installed at this stage, and additional configuration of the image itself is also allowed. Because of the ability to include runtime dependencies, it is possible to create a container without ",(0,t.jsx)(n.em,{children:"explicit build steps"})," that has just package dependencies, see ",(0,t.jsx)(n.a,{href:"/dalec/container-only-builds",children:"Container-only builds"})," for more information on this."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-package-and-container-from-source",children:"Creating a Package and Container from Source"}),"\n",(0,t.jsx)(n.p,{children:"Now, without further ado, let's get started."}),"\n",(0,t.jsx)(n.p,{children:"To do our build, we need a few things:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A list of sources to pull from"}),"\n",(0,t.jsx)(n.li,{children:"A build script to build the sources"}),"\n",(0,t.jsx)(n.li,{children:"A list of artifacts to include in the package"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In this example, we'll build the ",(0,t.jsx)(n.code,{children:"go-md2man"})," package and container from the ",(0,t.jsx)(n.a,{href:"https://github.com/cpuguy83/go-md2man",children:(0,t.jsx)(n.code,{children:"go-md2man"})})," repo using ",(0,t.jsx)(n.code,{children:"v2.0.3"})," tag in the repo."]}),"\n",(0,t.jsxs)(n.p,{children:["First, let's start with the constructing a ",(0,t.jsx)(n.a,{href:"/dalec/spec",children:"Dalec spec"})," file."]}),"\n",(0,t.jsx)(n.p,{children:"We define the metadata for the package in the spec. This includes the name, packager, vendor, license, website, and description of the package. You may notice that many of these fields appear in package manager metadata for rpm and deb packages. This is because Dalec will generate package files for these packaging systems and utilize this metadata."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# syntax=ghcr.io/azure/dalec/frontend:latest\nname: go-md2man\nversion: 2.0.3\nrevision: "1"\nlicense: MIT\ndescription: A tool to convert markdown into man pages (roff).\npackager: Dalec Example\nvendor: Dalec Example\nwebsite: https://github.com/cpuguy83/go-md2man\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["In metadata section, ",(0,t.jsx)(n.code,{children:"packager"}),", ",(0,t.jsx)(n.code,{children:"vendor"})," and ",(0,t.jsx)(n.code,{children:"website"})," may be optional fields, depending on the underlying target's\npackaging system (i.e., RPM, DEB, etc.)."]})}),"\n",(0,t.jsxs)(n.p,{children:["In the next section of the spec, we define the ",(0,t.jsx)(n.a,{href:"/dalec/sources",children:"sources"})," that we will be pulling from. In this case, we are pulling from a git repository."]}),"\n",(0,t.jsx)(n.p,{children:"One thing to note: in many build systems you will not have access to the Internet while building the package, and by default this is the case for all Dalec targets.\nThe reason for this is to ensure that the source packages Dalec produces can also be built without internet access."}),"\n",(0,t.jsxs)(n.p,{children:["For debugging purposes, if you ",(0,t.jsx)(n.em,{children:"do"})," need to access the internet during a build you can use the ",(0,t.jsx)(n.code,{children:"network_mode"})," field under the ",(0,t.jsx)(n.code,{children:"build"})," section of the spec, see ",(0,t.jsx)(n.a,{href:"/dalec/spec#build-section",children:"Spec#Build"}),". However, it is by far best practice to utilize a build process which can run in a network isolated environment, provided the proper dependencies are fetched beforehand."]}),"\n",(0,t.jsxs)(n.p,{children:["Due to the lack of internet access, the below build will fail because ",(0,t.jsx)(n.code,{children:"go build"})," will try to download the go modules. For this reason, we added a ",(0,t.jsx)(n.code,{children:"generate"})," section to the source to run ",(0,t.jsx)(n.code,{children:"go mod download"})," in a docker image with the ",(0,t.jsx)(n.code,{children:"src"})," source mounted and then extract the go modules from the resulting filesystem."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'sources:\n  # creates a directory in the build environment called "src" under which the source code will be checked out.\n  src:\n    git:\n      url: https://github.com/cpuguy83/go-md2man.git\n      commit: "v2.0.3"\n    generate:\n    # see note above; needed to fetch go modules ahead of time\n    # since network access is default disabled during build\n      - gomod: {}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the next section, we define the dependencies that are needed to build the package. In this case, we need the ",(0,t.jsx)(n.code,{children:"golang"})," dependency at the build time, and ",(0,t.jsx)(n.code,{children:"man-db"})," at runtime. Build dependencies are dependencies that are needed to build the package, while runtime dependencies are dependencies that are needed to run the package, i.e., they will be installed alongside the package when it is installed on a system. Runtime dependencies are not required for this specific example, but they are included for illustrative purposes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"dependencies:\n  build:\n    golang:\n  runtime:\n    # as stated above, included for illustrative purposes\n    man-db:\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, let's define the build steps. In this case, we are building the ",(0,t.jsx)(n.code,{children:"go-md2man"})," binary."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'build:\n  # the env section allows us to define environment variables \n  # that will be set during the build process\n  env:\n    CGO_ENABLED: "0"\n  steps:\n    - command: |\n        # this `src` is the directory created in the sources section above from checking out the git repo\n        cd src\n        go build -o go-md2man .\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Next, we define the artifacts that we want to include in the package. In this case, we are including the ",(0,t.jsx)(n.code,{children:"go-md2man"})," binary. Dalec allows for the inclusion of a variety of different artifact types in a package. For the full list, refer to the ",(0,t.jsx)(n.a,{href:"/dalec/artifacts",children:"artifacts"})," section."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"artifacts:\n  binaries:\n    src/go-md2man:\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The Image section defines the entrypoint and command for the image. In this case, we are setting the entrypoint to ",(0,t.jsx)(n.code,{children:"go-md2man"})," and the command to ",(0,t.jsx)(n.code,{children:"--help"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"image:\n  entrypoint: go-md2man\n  cmd: --help\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Finally, we can add a test case to the spec file which helps ensure the package is assembled as expected. The following test will make sure ",(0,t.jsx)(n.code,{children:"/usr/bin/go-md2man"})," is installed and has the expected permissions. These tests are automatically executed when building the container image. For more information on tests, see the ",(0,t.jsx)(n.a,{href:"/dalec/testing",children:"tests"})," section."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'tests:\n  - name: Check file permissions\n    files:\n      # The generated package will install go-md2man to /usr/bin because it was listed explicitly as a "binary" artifact\n      /usr/bin/go-md2man:\n        permissions: 0755\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now, let's put it all together in a single file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# syntax=ghcr.io/azure/dalec/frontend:latest\nname: go-md2man\nversion: 2.0.3\nrevision: "1"\npackager: Dalec Example\nvendor: Dalec Example\nlicense: MIT\ndescription: A tool to convert markdown into man pages (roff).\nwebsite: https://github.com/cpuguy83/go-md2man\n\nsources:\n  src:\n    generate:\n      - gomod: {}\n    git:\n      url: https://github.com/cpuguy83/go-md2man.git\n      commit: "v2.0.3"\n\ndependencies:\n  build:\n    golang:\n\nbuild:\n  env:\n    CGO_ENABLED: "0"\n  steps:\n    - command: |\n        cd src\n        go build -o go-md2man .\n\nartifacts:\n  binaries:\n    src/go-md2man:\n\nimage:\n  entrypoint: go-md2man\n  cmd: --help\n\ntests:\n  - name: Check bin\n    files:\n      /usr/bin/go-md2man:\n        permissions: 0755\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The full example can be found at ",(0,t.jsx)(n.a,{href:"https://github.com/Azure/dalec/blob/main/docs/examples/go-md2man.yml",children:"docs/examples/go-md2man.yml"})]})}),"\n",(0,t.jsxs)(n.p,{children:["Now that we have a spec file, we can build the package and container using ",(0,t.jsx)(n.code,{children:"docker"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"building-using-docker",children:"Building using Docker"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we'll go over how to actually ",(0,t.jsx)(n.em,{children:"perform"})," a build with Dalec once the spec file as been written. Other applicable Docker commands (such as ",(0,t.jsx)(n.code,{children:"--push"})," and others) will also apply to Dalec."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mariner2"})," target here is an example. You can find more information about available targets in the ",(0,t.jsx)(n.a,{href:"/dalec/targets",children:"targets"})," section."]})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Remember that steps are independent of each other. You don't have to build an RPM first to build a container."})}),"\n",(0,t.jsx)(n.h3,{id:"building-just-an-rpm-package",children:"Building just an RPM package"}),"\n",(0,t.jsx)(n.p,{children:"To build an RPM package only, we can use the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"docker build -t go-md2man:2.0.3 -f docs/examples/go-md2man.yml --target=mariner2/rpm --output=_output .\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will create ",(0,t.jsx)(n.code,{children:"RPM"})," and ",(0,t.jsx)(n.code,{children:"SRPM"})," directories in the ",(0,t.jsx)(n.code,{children:"_output"})," directory with the built RPM and SRPM packages respectively."]}),"\n",(0,t.jsx)(n.h3,{id:"building-a-container-with-the-package-installed",children:"Building a Container with the Package Installed"}),"\n",(0,t.jsx)(n.p,{children:"To build a container, we can use the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"docker build -t go-md2man:2.0.3 -f docs/examples/go-md2man.yml --target=mariner2 .\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will produce a container image named ",(0,t.jsx)(n.code,{children:"go-md2man:2.0.3"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>r});var t=i(6540);const a={},s=t.createContext(a);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);