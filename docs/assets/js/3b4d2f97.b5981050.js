"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[327,620],{2716:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"targets","title":"Targets","description":"DALEC is designed to support building artifacts for a number of different","source":"@site/docs/targets.md","sourceDirName":".","slug":"/targets","permalink":"/dalec/targets","draft":false,"unlisted":false,"editUrl":"https://github.com/Azure/dalec/blob/main/website/docs/targets.md","tags":[],"version":"current","frontMatter":{"title":"Targets"},"sidebar":"sidebar","previous":{"title":"Dependencies","permalink":"/dalec/dependencies"},"next":{"title":"Testing","permalink":"/dalec/testing"}}');var a=i(4848),s=i(8453),r=i(7601);const o={title:"Targets"},l=void 0,d={},c=[{value:"Available Targets",id:"available-targets",level:2},...r.toc,{value:"Dependencies",id:"dependencies",level:2},{value:"Extensibility",id:"extensibility",level:2},{value:"Advanced Customization",id:"advanced-customization",level:2},{value:"Worker images",id:"worker-images",level:3},{value:"Source Policies",id:"source-policies",level:3},{value:"Named Build Contexts",id:"named-build-contexts",level:3},{value:"Target Defined Artifacts",id:"target-defined-artifacts",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["DALEC is designed to support building artifacts for a number of different\nsystems.\nDALEC refers to these in the ",(0,a.jsx)(n.a,{href:"/dalec/spec",children:"spec"}),' as "targets".\nWhen executing a build with Docker these targets can be specified with the\n',(0,a.jsx)(n.code,{children:"--target=<target>"})," flag."]}),"\n",(0,a.jsx)(n.h2,{id:"available-targets",children:"Available Targets"}),"\n",(0,a.jsx)(n.p,{children:"DALEC includes a number of built-in targets that you can either use in your spec."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"mariner2"})," - Azure Linux 2 (formerly CBL-Mariner)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"azlinux3"})," - Azure Linux 3"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"bullseye"})," - Debian 11 (Bullseye) (v0.11)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"bookworm"})," - Debian 12 (Bookworm) (v0.11)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"bionic"})," - Ubuntu 18.04 (Bionic) (v0.11)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"focal"})," - Ubuntu 20.04 (focal) (v0.11)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"jammy"})," - Ubuntu 22.04 (jammy) (v0.9)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"noble"})," - Ubuntu 24.04 (noble) (v0.11)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"windowscross"})," - Cross compile from Ubuntu Jammy to Windows"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['When specifying a "target" to ',(0,a.jsx)(n.code,{children:"docker build --target=<target>"})," DALEC treats\n",(0,a.jsx)(n.code,{children:"<target>"})," as a route (much like an HTTP path) and each of the above mentioned\ntargets have subroutes you can specfiy as well, e.g. ",(0,a.jsx)(n.code,{children:"jammy/deb"})," to have DALEC\nbuild and output just the deb package. What subroutes are available depend on\nthe underlying target implementation."]}),"\n",(0,a.jsx)(n.p,{children:"To print a list of available build targets:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:'$ docker buildx build --call targets --build-arg BUILDKIT_SYNTAX=ghcr.io/azure/dalec/frontend:latest - <<< "null"\n'})}),"\n","\n",(0,a.jsxs)(i,{children:[(0,a.jsx)("summary",{children:"DALEC targets list output"}),(0,a.jsx)("pre",{children:(0,a.jsx)(r.default,{})})]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:'The above command is passing in a "null" value as the build spec and telling\nbuildkit to use the latest dalec version.\nThis output can change depending on version or spec you provide.'})}),"\n",(0,a.jsxs)(n.p,{children:["To check the targets available for a specific spec you can just add ",(0,a.jsx)(n.code,{children:"--call targets"}),"\nto your normal ",(0,a.jsx)(n.code,{children:"docker build"})," command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"$ docker buildx build --call targets -f ./path/to/spec .\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the ",(0,a.jsx)(n.code,{children:"--target=<val>"})," flag is set, the list of targets will be filtered based\non ",(0,a.jsx)(n.code,{children:"<val>"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Likewise if the spec file contains items in the ",(0,a.jsx)(n.code,{children:"targets"})," section then the list\nof available targets will be filtered to just the targets in the spec."]}),"\n",(0,a.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,a.jsxs)(n.p,{children:["Many components, such as package dependencies and base images, are specific to\na distro or a subset of distros. The dalec spec allows you to move these distro\nspecific things into a ",(0,a.jsx)(n.code,{children:"target"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Instead of specifying a package dependency at the root of the spec, you can specify it under a target.\nThis allows you to include different packages for different targets."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Please note that dependencies under a target will override dependencies at the root level."})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"targets:\n  mariner2:\n    dependencies:\n      build:\n        - golang\n"})}),"\n",(0,a.jsx)(n.h2,{id:"extensibility",children:"Extensibility"}),"\n",(0,a.jsx)(n.p,{children:"Dalec can\u2019t feasibly support every Linux distribution. Instead, it gives you the flexibility to specify a custom builder image for any target, directing the build process to that specified image."}),"\n",(0,a.jsxs)(n.p,{children:["This method allows for the use of a single spec file for all targets, employing one ",(0,a.jsx)(n.code,{children:"#syntax="})," directive to build the package for any specified target. It also permits the replacement of the default targets with custom builder configurations."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"targets:\n  mariner2:\n    frontend:\n      image: docker.io/my/custom:mariner2\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-customization",children:"Advanced Customization"}),"\n",(0,a.jsx)(n.h3,{id:"worker-images",children:"Worker images"}),"\n",(0,a.jsx)(n.p,{children:"In some cases you may need to have additional things installed in the worker\nimage that are not typically available in the base image. As an example, a\npackage dependency may not be available in the default package repositories."}),"\n",(0,a.jsxs)(n.p,{children:["You can have Dalec output an image with the target's worker image with\n",(0,a.jsx)(n.code,{children:"<target>/worker>"})," build target, e.g. ",(0,a.jsx)(n.code,{children:"--target=mariner2/worker"}),". You can then\nadd any customizations and feed that back in via ",(0,a.jsx)(n.a,{href:"#source-policies",children:"source polices"}),"\nor ",(0,a.jsx)(n.a,{href:"#named-build-contexts",children:"named build contexts"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"source-policies",children:"Source Policies"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"docker buildx build"})," has experimental support for providing a\n",(0,a.jsx)(n.a,{href:"https://docs.docker.com/build/building/variables/#experimental_buildkit_source_policy",children:"source policy"}),"\nwhich updates the base image ref used to create the worker image. This method\nwill update any and all references to the matched image used for any part of\nthe build. It also requires knowing the image(s) that are used ahead of time and\ncreating the right set of match rules and potentially having to update this in\nthe future if the worker image refs in Dalec change."]}),"\n",(0,a.jsxs)(n.p,{children:["A finer grained approach is to use ",(0,a.jsx)(n.a,{href:"#named-build-contexts",children:"named build contexts"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"named-build-contexts",children:"Named Build Contexts"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"docker buildx build"})," has a flag called ",(0,a.jsx)(n.code,{children:"--build-context"}),"\n(",(0,a.jsx)(n.a,{href:"https://docs.docker.com/reference/cli/docker/buildx/build/#build-context",children:"doc"}),")\nwhich allows you to provide additional build contexts apart from the main build\ncontext in the form of ",(0,a.jsx)(n.code,{children:"<name>=<ref>"}),". See the prior linked documentation for\nwhat can go into ",(0,a.jsx)(n.code,{children:"<ref>"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.code,{children:"mariner2"})," target, Dalec looks for a named context called either"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The actual base image used internally for mariner2\ni. ",(0,a.jsx)(n.code,{children:"--build-context mcr.microsoft.com/cbl-mariner/base/core:2.0=<new ref>"})]}),"\n",(0,a.jsxs)(n.li,{children:["A build context named ",(0,a.jsx)(n.code,{children:"dalec-mariner2-worker"}),"\ni. ",(0,a.jsx)(n.code,{children:"--build-context dalec-mariner2-worker=<new ref>"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If 1 is provided, then 2 is ignored."}),"\n",(0,a.jsxs)(n.p,{children:["This works the same way in the ",(0,a.jsx)(n.code,{children:"azlinux3"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The actual base image used internally for azlinux3\ni. ",(0,a.jsx)(n.code,{children:"--build-context mcr.microsoft.com/azurelinux/base/core:3.0=<new ref>"})]}),"\n",(0,a.jsxs)(n.li,{children:["A build context named ",(0,a.jsx)(n.code,{children:"dalec-mariner2-worker"}),"\ni. ",(0,a.jsx)(n.code,{children:"--build-context dalec-azlinux3-worker=<new ref>"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"target-defined-artifacts",children:"Target Defined Artifacts"}),"\n",(0,a.jsxs)(n.p,{children:["There are some situations where you may want to have multiple builds and for those different\ntargets they may require different binaries to exist that are not globally applicable to all\nof the builds. For example, ",(0,a.jsx)(n.code,{children:"windowscross"})," may require specific artifacts (binaries, docs,\nconfig files, etc.) that are not relevant to ",(0,a.jsx)(n.code,{children:"azlinux3"}),", and vice versa."]}),"\n",(0,a.jsx)(n.p,{children:"To address this you can define artifacts per target. Target-defined artifacts will override\nglobal (spec-defined) artifacts if there is a conflict. However, if a target does not define\nan artifact, it will inherit artifacts from the global spec."}),"\n",(0,a.jsx)(n.p,{children:"Here is an example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'targets:\n  windowscross:\n    artifacts:\n      binaries:\n        bin/windows-cross.exe:\n          subpath: ""\n          mode: 0o755\n  azlinux3:\n    artifacts:\n      binaries:\n        bin/linux-binary:\n          subpath: ""\n          permissions: 0o755\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For more details on how Artifacts are structured and configured, see the ",(0,a.jsx)(n.a,{href:"/dalec/artifacts",children:"Artifacts"})," documentation."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},7601:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"examples/targets","title":"targets","description":"TARGET                           DESCRIPTION","source":"@site/docs/examples/targets.md","sourceDirName":"examples","slug":"/examples/targets","permalink":"/dalec/examples/targets","draft":false,"unlisted":false,"editUrl":"https://github.com/Azure/dalec/blob/main/website/docs/examples/targets.md","tags":[],"version":"current","frontMatter":{}}');var a=i(4848),s=i(8453);const r={},o=void 0,l={},d=[];function c(e){const n={p:"p",...(0,s.R)(),...e.components};return(0,a.jsx)(n.p,{children:"TARGET                           DESCRIPTION\nazlinux3/container (default)     Builds a container image for Azure Linux 3\nazlinux3/container/depsonly      Builds a container image with only the runtime dependencies installed.\nazlinux3/rpm                     Builds an rpm and src.rpm.\nazlinux3/rpm/debug/buildroot     Outputs an rpm buildroot suitable for passing to rpmbuild.\nazlinux3/rpm/debug/sources       Outputs all the sources specified in the spec file in the format given to rpmbuild.\nazlinux3/rpm/debug/spec          Outputs the generated RPM spec file\nazlinux3/worker                  Builds the base worker image responsible for building the rpm\nbionic/deb (default)             Builds a deb package.\nbionic/dsc                       Builds a Debian source package.\nbionic/testing/container         Builds a container image for testing purposes only.\nbionic/worker                    Builds the worker image.\nbookworm/deb (default)           Builds a deb package.\nbookworm/dsc                     Builds a Debian source package.\nbookworm/testing/container       Builds a container image for testing purposes only.\nbookworm/worker                  Builds the worker image.\nbullseye/deb (default)           Builds a deb package.\nbullseye/dsc                     Builds a Debian source package.\nbullseye/testing/container       Builds a container image for testing purposes only.\nbullseye/worker                  Builds the worker image.\ndebug/gomods                     Outputs all the gomodule dependencies for the spec\ndebug/cargohome                  Outputs all the cargohome dependencies for the spec\ndebug/resolve                    Outputs the resolved dalec spec file with build args applied.\ndebug/sources                    Outputs all sources from a dalec spec file.\nfocal/deb (default)              Builds a deb package.\nfocal/dsc                        Builds a Debian source package.\nfocal/testing/container          Builds a container image for testing purposes only.\nfocal/worker                     Builds the worker image.\njammy/deb (default)              Builds a deb package.\njammy/dsc                        Builds a Debian source package.\njammy/testing/container          Builds a container image for testing purposes only.\njammy/worker                     Builds the worker image.\nmariner2/container (default)     Builds a container image for CBL-Mariner 2\nmariner2/container/depsonly      Builds a container image with only the runtime dependencies installed.\nmariner2/rpm                     Builds an rpm and src.rpm.\nmariner2/rpm/debug/buildroot     Outputs an rpm buildroot suitable for passing to rpmbuild.\nmariner2/rpm/debug/sources       Outputs all the sources specified in the spec file in the format given to rpmbuild.\nmariner2/rpm/debug/spec          Outputs the generated RPM spec file\nmariner2/worker                  Builds the base worker image responsible for building the rpm\nnoble/deb (default)              Builds a deb package.\nnoble/dsc                        Builds a Debian source package.\nnoble/testing/container          Builds a container image for testing purposes only.\nnoble/worker                     Builds the worker image.\nwindowscross/container (default) Builds binaries and installs them into a Windows base image\nwindowscross/worker              Builds the base worker image responsible for building the package\nwindowscross/zip                 Builds binaries combined into a zip file"})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);