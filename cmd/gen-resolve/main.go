package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"sort"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <output-file>\n", os.Args[0])
		os.Exit(1)
	}

	outputFile := os.Args[1]

	// Parse the spec.go file to extract Spec struct fields
	specFields, err := extractSpecFields()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error extracting spec fields: %v\n", err)
		os.Exit(1)
	}

	// Generate the code
	code, err := generateResolveMethod(specFields)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating code: %v\n", err)
		os.Exit(1)
	}

	// Write to output file
	err = os.WriteFile(outputFile, code, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated Resolve method in %s\n", outputFile)
}

type SpecField struct {
	Name     string // Field name (e.g. "Name")
	TypeName string // Type name (e.g. "string")
	IsSlice  bool   // Is it a slice type
	IsMap    bool   // Is it a map type
	IsPtr    bool   // Is it a pointer type
}

func extractSpecFields() ([]SpecField, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "spec.go", nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse spec.go: %w", err)
	}

	var specFields []SpecField

	// Find the Spec struct
	ast.Inspect(node, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok && ts.Name.Name == "Spec" {
			if st, ok := ts.Type.(*ast.StructType); ok {
				for _, field := range st.Fields.List {
					if len(field.Names) == 0 {
						continue // Skip embedded fields
					}

					fieldName := field.Names[0].Name
					
					// Skip unexported fields and fields that are internal
					if !ast.IsExported(fieldName) || fieldName == "extensions" || fieldName == "decodeOpts" {
						continue
					}

					typeName, isSlice, isMap, isPtr := parseFieldType(field.Type)
					
					specFields = append(specFields, SpecField{
						Name:     fieldName,
						TypeName: typeName,
						IsSlice:  isSlice,
						IsMap:    isMap,
						IsPtr:    isPtr,
					})
				}
			}
		}
		return true
	})

	// Sort fields for consistent output
	sort.Slice(specFields, func(i, j int) bool {
		return specFields[i].Name < specFields[j].Name
	})

	return specFields, nil
}

func parseFieldType(expr ast.Expr) (typeName string, isSlice, isMap, isPtr bool) {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name, false, false, false
	case *ast.StarExpr:
		name, slice, mp, _ := parseFieldType(t.X)
		return name, slice, mp, true
	case *ast.ArrayType:
		if t.Len == nil { // slice
			name, _, mp, ptr := parseFieldType(t.Elt)
			return name, true, mp, ptr
		}
		return "array", false, false, false // fixed-size array
	case *ast.MapType:
		return "map", false, true, false
	case *ast.SelectorExpr:
		// Handle qualified identifiers like pkg.Type
		if ident, ok := t.X.(*ast.Ident); ok {
			return fmt.Sprintf("%s.%s", ident.Name, t.Sel.Name), false, false, false
		}
		return "selector", false, false, false
	default:
		return "unknown", false, false, false
	}
}

func generateResolveMethod(fields []SpecField) ([]byte, error) {
	var buf bytes.Buffer

	// Generate file header
	buf.WriteString(`// Code generated by cmd/gen-resolve. DO NOT EDIT.

package dalec

`)

	// Start the Resolve method
	buf.WriteString("// Resolve creates a new Spec with target-specific configuration merged in.\n")
	buf.WriteString("// This eliminates the need to pass targetKey parameters around by pre-resolving\n")
	buf.WriteString("// all target-specific configuration into a single Spec.\n")
	buf.WriteString("func (s *Spec) Resolve(targetKey string) *Spec {\n")
	buf.WriteString("\t// Create a deep copy of the current spec\n")
	buf.WriteString("\tresolved := &Spec{\n")

	// Define fields that need special handling
	specialFields := map[string]bool{
		"Tests":         true, // Merge global + target-specific
		"Dependencies":  true, // Resolved via GetPackageDeps
		"PackageConfig": true, // Target overrides global
		"Image":         true, // Resolved via MergeSpecImage
		"Artifacts":     true, // Resolved via GetArtifacts
		"Provides":      true, // Resolved via GetProvides
		"Replaces":      true, // Resolved via GetReplaces  
		"Conflicts":     true, // Resolved via GetConflicts
		"Targets":       true, // Cleared (set to nil)
	}

	// Copy basic fields
	for _, field := range fields {
		if !specialFields[field.Name] {
			buf.WriteString(fmt.Sprintf("\t\t%s: s.%s,\n", field.Name, field.Name))
		}
	}

	buf.WriteString("\t}\n\n")

	// Copy extension fields
	buf.WriteString("\t// Copy extension fields\n")
	buf.WriteString("\tif s.extensions != nil {\n")
	buf.WriteString("\t\tresolved.extensions = make(extensionFields)\n")
	buf.WriteString("\t\tfor k, v := range s.extensions {\n")
	buf.WriteString("\t\t\tresolved.extensions[k] = v\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n\n")

	// Handle special fields with target-specific resolution logic
	buf.WriteString("\t// Merge tests (global + target-specific)\n")
	buf.WriteString("\tresolved.Tests = append([]*TestSpec(nil), s.Tests...)\n")
	buf.WriteString("\tif target, ok := s.Targets[targetKey]; ok && target.Tests != nil {\n")
	buf.WriteString("\t\tresolved.Tests = append(resolved.Tests, target.Tests...)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Resolve dependencies by merging global and target-specific\n")
	buf.WriteString("\tresolved.Dependencies = s.GetPackageDeps(targetKey)\n\n")

	buf.WriteString("\t// Resolve package config (target overrides global)\n")
	buf.WriteString("\tresolved.PackageConfig = s.PackageConfig\n")
	buf.WriteString("\tif target, ok := s.Targets[targetKey]; ok && target.PackageConfig != nil {\n")
	buf.WriteString("\t\tresolved.PackageConfig = target.PackageConfig\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Resolve image config by merging\n")
	buf.WriteString("\tresolved.Image = MergeSpecImage(s, targetKey)\n\n")

	buf.WriteString("\t// Resolve artifacts\n")
	buf.WriteString("\tresolved.Artifacts = s.GetArtifacts(targetKey)\n\n")

	buf.WriteString("\t// Resolve provides, replaces, conflicts\n")
	buf.WriteString("\tresolved.Provides = s.GetProvides(targetKey)\n")
	buf.WriteString("\tresolved.Replaces = s.GetReplaces(targetKey)\n")
	buf.WriteString("\tresolved.Conflicts = s.GetConflicts(targetKey)\n\n")

	buf.WriteString("\t// Clear targets as this is now a resolved spec for a specific target\n")
	buf.WriteString("\tresolved.Targets = nil\n\n")

	buf.WriteString("\treturn resolved\n")
	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}